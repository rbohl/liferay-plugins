import com.liferay.portal.kernel.util.ReleaseInfo

import org.gradle.api.internal.file.copy.CopySpecResolver

apply plugin: "war"

buildscript {
	dependencies {
		classpath group: "com.liferay.portal", name: "portal-service", version: "7.0.0-SNAPSHOT"
	}

	repositories {
		maven {
			url "http://cdn.repository.liferay.com/nexus/content/groups/public"
		}
	}
}

configurations {
	portal

	portalBuildCss {
		extendsFrom portal
	}

	portalWeb
}

dependencies {
	File projectServiceJarFile = file("docroot/WEB-INF/lib/${name}-service.jar")

	if (projectServiceJarFile.exists()) {
		compile files(projectServiceJarFile)
	}

	Map projectCompileDependencies = gradle.compileDependencies.find {
		project.path == it.projectPath
	}

	if (projectCompileDependencies) {
		projectCompileDependencies["compile"].each {
			compile project(it)
		}
	}

	if (!name.endsWith("-layouttpl") && !name.equals("portal-compat-shared")) {
		compile project(":shared:portal-compat-shared")
	}

	portal(
		[group: "com.liferay.portal", name: "portal-impl", version: "7.0.0-SNAPSHOT"],
		[group: "com.liferay.portal", name: "portal-service", version: "7.0.0-SNAPSHOT"],
		[group: "com.liferay.portal", name: "util-java", version: "7.0.0-SNAPSHOT"],
		[group: "com.thoughtworks.xstream", name: "xstream", version: "1.4.3"],
		[group: "commons-configuration", name: "commons-configuration", version: "1.6"],
		[group: "commons-lang", name: "commons-lang", version: "2.6"],
		[group: "easyconf", name: "easyconf", version: "0.9.5", transitive: false],
		[group: "javax.servlet", name: "javax.servlet-api", version: "3.0.1"]
	)

	portalBuildCss(
		[group: "com.liferay", name: "com.liferay.ruby.gems", version: "1.0.0-SNAPSHOT"],
		[group: "javax.portlet", name: "portlet-api", version: "2.0"],
		[group: "org.apache.ant", name: "ant", version: "1.8.2"],
		[group: "org.jruby", name: "jruby-complete", version: "1.6.5"],
		[group: "org.mozilla", name: "rhino", version: "1.7R4"],
		[group: "org.springframework", name: "spring-web", version: "3.2.10.RELEASE"],
		[group: "struts", name: "struts", version: "1.2.9"]
	)

	portalWeb group: "com.liferay.portal", name: "portal-web", version: "7.0.0-SNAPSHOT"

	providedCompile(
		[group: "biz.aQute.bnd", name: "biz.aQute.bnd", version: "2.4.1"],
		[group: "com.liferay.portal", name: "portal-service", version: "7.0.0-SNAPSHOT"],
		[group: "com.liferay.portal", name: "util-bridges", version: "7.0.0-SNAPSHOT"],
		[group: "com.liferay.portal", name: "util-java", version: "7.0.0-SNAPSHOT"],
		[group: "com.liferay.portal", name: "util-taglib", version: "7.0.0-SNAPSHOT"],
		[group: "commons-logging", name: "commons-logging", version: "1.1.1"],
		[group: "hsqldb", name: "hsqldb", version: "1.8.0.7"],
		[group: "javax.activation", name: "activation", version: "1.1"],
		[group: "javax.ccpp", name: "ccpp", version: "1.0"],
		[group: "javax.jms", name: "jms", version: "1.1"],
		[group: "javax.mail", name: "mail", version: "1.4"],
		[group: "javax.portlet", name: "portlet-api", version: "2.0"],
		[group: "javax.servlet", name: "javax.servlet-api", version: "3.0.1"],
		[group: "javax.servlet.jsp", name: "jsp-api", version: "2.1"],
		[group: "log4j", name: "log4j", version: "1.2.16"],
		[group: "mysql", name: "mysql-connector-java", version: "5.1.23"],
		[group: "net.sf", name: "jargs", version: "1.0"],
		[group: "net.sourceforge.jtds", name: "jtds", version: "1.2.6"],
		[group: "org.eclipse.persistence", name: "javax.persistence", version: "2.0.0"],
		[group: "postgresql", name: "postgresql", version: "9.2-1002.jdbc4"]
	)
}

sourceSets {
	main {
		java {
			srcDir pluginSrcDir
		}

		resources {
			srcDir pluginSrcDir
		}
	}
}

String moduleFullVersion = pluginPackageProperties["module-full-version"]

if (moduleFullVersion) {
	version = moduleFullVersion
}
else {
	String bundleVersion = bndProperties["Bundle-Version"]

	if (bundleVersion) {
		version = bundleVersion
	}
	else {
		String moduleIncrementalVersion = pluginPackageProperties["module-incremental-version"]

		if (!moduleIncrementalVersion) {
			moduleIncrementalVersion = getBuildXmlProperty("plugin.version")
		}

		version = getBuildXmlProperty("plugin.full.version", ReleaseInfo.version + "." + moduleIncrementalVersion)
	}
}

webAppDirName = "docroot"

task buildCss(type: JavaExec)
task compile
task initGradle

buildCss {
	File sassDocrootDir
	FileTree sassDocrootDirFileTree

	if (osgiPlugin) {
		sassDocrootDir = file("src/META-INF/resources")
	}
	else {
		sassDocrootDir = file("docroot")
	}

	sassDocrootDirFileTree = fileTree(dir: sassDocrootDir, include: "**/*.css")

	args(
		"sass.dir=/",
		"sass.docroot.dir=${sassDocrootDir}",
		"sass.portal.common.dir=${rootDir}/tmp/portal-web/html/css/common"
	)

	classpath configurations.portalBuildCss

	doFirst {
		if (!exists("${rootDir}/tmp/portal-web")) {
			copy {
				from(zipTree(configurations.portalWeb.singleFile)) {
					include "html/css/**/*"
					include "html/themes/**/*"
					include "WEB-INF/tld/**/*"
				}

				into "${rootDir}/tmp/portal-web"
			}
		}
	}

	main = "com.liferay.portal.tools.SassToCssBuilder"

	onlyIf {
		sassDocrootDirFileTree.files
	}

	outputs.dir "${rootDir}/tmp"

	sassDocrootDirFileTree.each {
		outputs.dir "${it}/../.sass-cache"
	}
}

clean {
	afterEvaluate {
		tasks.each {
			dependsOn "clean" + it.name.capitalize()
		}
	}

	Map projectCompileDependencies = gradle.compileDependencies.find {
		project.path == it.projectPath
	}

	if (projectCompileDependencies) {
		projectCompileDependencies["compile"].each {
			dependsOn "${it}:clean"
		}
	}
}

compile {
	dependsOn compileJava
}

initGradle << {
	Closure getBuildGradleDependencies
	Closure getBuildGradleDependenciesCompile
	Closure getBuildGradleDependenciesProvidedCompile
	Closure getBuildGradleDependenciesTestCompile
	Closure getIndent
	Closure wrapContents
	Closure wrapDependency
	Closure wrapProperty
	Closure wrapServiceJar
	Closure writeBuildGradleFile
	Closure writeDependencySettingsFile

	getBuildGradleDependencies = {
		List contents = []

		contents.addAll(getBuildGradleDependenciesCompile())
		contents.addAll(getBuildGradleDependenciesProvidedCompile())
		contents.addAll(getBuildGradleDependenciesTestCompile())

		return wrapContents(contents, 0, " {", "dependencies", "}")
	}

	getBuildGradleDependenciesCompile = {
		List contents = []

		if (ivyXmlNode) {
			ivyXmlNode.dependencies.dependency.each {
				if ((it.@conf == null) || (it.@conf == "default")) {
					contents.addAll(wrapDependency(2, it.@org, it.@name, it.@rev))
				}
			}
		}

		String requiredDeploymentContexts = pluginPackageProperties["required-deployment-contexts"]

		if (requiredDeploymentContexts) {
			String[] requiredDeploymentContextsArray = requiredDeploymentContexts.split(",")

			requiredDeploymentContextsArray.each {
				String serviceJarFileName = "../../" + it.replaceFirst(".+-", "") + "s/${it}/docroot/WEB-INF/lib/${it}-service.jar"

				File serviceJarFile = new File("${projectDir}", serviceJarFileName)

				if (serviceJarFile.exists()) {
					contents.addAll(wrapServiceJar(2, serviceJarFileName))
				}
			}
		}

		return wrapContents(contents, 1, "(", "compile", ")")
	}

	getBuildGradleDependenciesProvidedCompile = {
		List contents = []

		String portalDependencyJars = pluginPackageProperties["portal-dependency-jars"]

		if (portalDependencyJars) {
			portalDependencyJars = portalDependencyJars.replaceAll("\\.jar", "")
			portalDependencyJars = portalDependencyJars.replaceAll("-\\w") {
				it[1].toUpperCase()
			}

			String[] portalDependencyJarsArray = portalDependencyJars.split(",")

			portalDependencyJarsArray.each {
				String portalDependencyJar ->

				Map portalDependencyJarMap = portalDependencies[portalDependencyJar]

				if (portalDependencyJarMap == null) {
					println("Portal dependency " + portalDependencyJar + " is not defined in versions.gradle")
				}
				else {
					contents.addAll(wrapDependency(2, portalDependencyJarMap["group"], portalDependencyJarMap["name"], portalDependencyJarMap["version"]))
				}
			}

		}

		return wrapContents(contents, 1, "(", "providedCompile", ")")
	}

	getBuildGradleDependenciesTestCompile = {
		List contents = []

		if (ivyXmlNode) {
			ivyXmlNode.dependencies.dependency.each {
				if (it.@conf =~ "test") {
					contents.addAll(wrapDependency(2, it.@org, it.@name, it.@rev))
				}
			}
		}

		return wrapContents(contents, 1, "(", "testCompile", ")")
	}

	getIndent = {
		String indent = ""

		it.times(
		{
			indent = indent + "\t"
		})

		return indent
	}

	wrapContents = {
		List contents, int indentCount, String leftClose, String name, String rightClose ->

		if (!contents) {
			return contents
		}

		String indent = getIndent(indentCount)

		contents.add(0, indent + name + leftClose)

		String content = contents.last()

		if (content.endsWith(",")) {
			contents.pop()

			contents << content.substring(0, content.length() - 1)
		}

		contents << indent + rightClose

		return contents
	}

	wrapDependency = {
		int indentCount, String group, String name, String version ->

		return "${getIndent(indentCount)}[group: \"${group}\", name: \"${name}\", version: \"${version}\"],"
	}

	wrapProperty = {
		int indentCount, String name, String value = "" ->

		if (value) {
			return "${getIndent(indentCount)}${name} = \"${value}\""
		}

		return []
	}

	wrapServiceJar = {
		int indentCount, String serviceJarFileName ->

		return "${getIndent(indentCount)}files(\"${serviceJarFileName}\"),"
	}

	writeBuildGradleFile = {
		List contents = []

		contents.addAll(getBuildGradleDependencies())

		File buildGradleFile = new File("${projectDir}/build.gradle")

		contents.each {
			buildGradleFile << it + "\n"
		}
	}

	writeDependencySettingsFile = {
		File dependencySettingsFile = new File("${projectDir}/dependency-settings.gradle")

		String importShared = getBuildXmlProperty("import.shared")

		if (importShared) {
			List contents = []

			String[] importSharedArray = importShared.split(",")

			importSharedArray.each {
				String includeTransitivePath

				if (exists("${rootDir}/shared/${it}/src")) {
					includeTransitivePath = ":shared:${it}"
				}
				else if (exists("${projectDir}/../${it}/src")) {
					includeTransitivePath = project.path.replaceFirst(project.name, it)
				}
				else {
					println("Project dependency ${it} could not be found in the shared directory or this project's parent directory.")

					return
				}

				contents << "includeTransitive \"${includeTransitivePath}\""
			}

			contents.each {
				dependencySettingsFile << it + "\n"
			}
		}
		else {
			dependencySettingsFile.delete()
		}
	}

	// build.gradle

	writeBuildGradleFile()

	// dependency-settings.gradle

	writeDependencySettingsFile()
}

war {
	Closure getLanguageProperties
	Closure getNewDependencyNames
	Closure setManifest

	dependsOn buildCss

	destinationDir = file("${rootDir}/dist2")

	duplicatesStrategy "exclude"

	exclude "_diffs.*", "_diffs/**", "WEB-INF/lib/*"

	filesMatching("WEB-INF/liferay-hook.xml") {
		filter {
			line ->

			line.contains("content/Language*.properties") ? getLanguageProperties() : line
		}
	}

	getLanguageProperties = {
		StringBuilder sb = new StringBuilder()

		File contentDir = file("${pluginSrcDir}/content")

		File[] files = contentDir.listFiles()

		for (int i = 0; i < files.length; i++) {
			File file = files[i]

			sb << "\t<language-properties>content/" + file.name + "</language-properties>"

			if ((i + 1) < files.length) {
				sb << "\n"
			}
		}

		return sb.toString()
	}

	getNewDependencyNames = {
		configurations.compile.resolvedConfiguration.resolvedArtifacts.collectEntries {
			ModuleVersionIdentifier moduleVersionIdentifier = it.moduleVersion.id

			[(String)"${moduleVersionIdentifier.name}-${moduleVersionIdentifier.version}.jar", (String)"${moduleVersionIdentifier.name}.jar"]
		}
	}.memoize()

	setManifest = {
		File manifestFile

		if (osgiPlugin) {
			manifestFile = file("src/META-INF/MANIFEST.MF")
		}
		else {
			manifestFile = file("docroot/META-INF/MANIFEST.MF")
		}

		if (manifestFile.exists()) {
			manifest.from manifestFile
		}
		else {
			CopySpec copySpec = rootSpec.children.find {
				CopySpecResolver copySpecResolver = it.buildRootResolver()

				copySpecResolver.destPath.pathString == "META-INF"
			}

			if (copySpec) {
				copySpec.exclude "**"
			}
		}
	}

	outputs.file archivePath

	rootSpec.children*.rename {
		String fileName ->

		Map<String, String> newDependencyNames = getNewDependencyNames();

		return newDependencyNames[fileName] ?: fileName
	}

	setManifest()
}